name: Build LibOpusFile

on: [push, pull_request]

jobs:
  build:
    name: ${{ matrix.name }}
    runs-on: ${{ matrix.os }}
    defaults:
      run:
        shell: bash
    strategy:
      fail-fast: false
      matrix:
        include:
          # --- DESKTOP (Linux x64) ---
          - name: Linux x86_64
            os: ubuntu-latest
            triplet: x64-linux
            folder: linux_x86_64

          # --- WINDOWS (MinGW) ---
          - name: Windows MinGW x64
            os: windows-latest
            triplet: x64-mingw-static
            setup_cmd: choco install mingw
            extra_cmake_args: '-G "MinGW Makefiles"'
            folder: windows_x86_64

          - name: Windows MinGW x86
            os: windows-latest
            triplet: x86-mingw-static
            setup_cmd: choco install mingw --forcex86
            extra_cmake_args: '-G "MinGW Makefiles"'
            folder: windows_x86

          # --- ANDROID ---
          # Android builds run on Ubuntu, so we use Linux paths for NDK
          - name: Android ARM64 (v8a)
            os: ubuntu-latest
            triplet: arm64-android
            is_android: true
            extra_cmake_args: "-DANDROID_ABI=arm64-v8a -DANDROID_PLATFORM=android-24"
            folder: android_abi_arm64_v8a

          - name: Android ARM32 (v7a)
            os: ubuntu-latest
            triplet: arm-android
            is_android: true
            patch_android_arm: true
            extra_cmake_args: "-DANDROID_ABI=armeabi-v7a -DANDROID_PLATFORM=android-24"
            folder: android_abi_armeabi_v7a

          - name: Android x86_64
            os: ubuntu-latest
            triplet: x64-android
            is_android: true
            extra_cmake_args: "-DANDROID_ABI=x86_64 -DANDROID_PLATFORM=android-24"
            folder: android_abi_x86_64

          - name: Android x86
            os: ubuntu-latest
            triplet: x86-android
            is_android: true
            extra_cmake_args: "-DANDROID_ABI=x86 -DANDROID_PLATFORM=android-24"
            folder: android_abi_x86

          # --- iOS ---
          - name: iOS ARM64 (Device)
            os: macos-latest
            triplet: arm64-ios
            extra_cmake_args: "-DCMAKE_SYSTEM_NAME=iOS"
            folder: ios_iphoneos_arm64

          - name: iOS Simulator (x64)
            os: macos-latest
            triplet: x64-ios
            extra_cmake_args: "-DCMAKE_SYSTEM_NAME=iOS"
            folder: ios_iphonesimulator_x86_64

          - name: iOS Simulator (ARM64)
            os: macos-latest
            triplet: arm64-ios-simulator
            extra_cmake_args: "-DCMAKE_SYSTEM_NAME=iOS"
            folder: ios_iphonesimulator_arm64

          # --- macOS ---
          - name: macOS ARM64 (Apple Silicon)
            os: macos-latest
            triplet: arm64-osx
            folder: macosx_arm64

          - name: macOS x64 (Intel)
            os: macos-latest
            triplet: x64-osx
            folder: macosx_x86_64

          # --- CROSS-COMPILE LINUX ---
          - name: Linux ARM64 (aarch64)
            os: ubuntu-latest
            triplet: arm64-linux
            setup_cmd: |
              sudo apt-get update
              sudo apt-get install -y gcc-aarch64-linux-gnu g++-aarch64-linux-gnu
            cross_cc: aarch64-linux-gnu-gcc
            cross_cxx: aarch64-linux-gnu-g++
            folder: linux_arm64

          - name: Linux ARM (armhf)
            os: ubuntu-latest
            triplet: arm-linux
            setup_cmd: |
              sudo apt-get update
              sudo apt-get install -y gcc-arm-linux-gnueabihf g++-arm-linux-gnueabihf
            cross_cc: arm-linux-gnueabihf-gcc
            cross_cxx: arm-linux-gnueabihf-g++
            patch_opus: true
            folder: linux_arm

          - name: Linux RISC-V 64
            os: ubuntu-latest
            triplet: riscv64-linux
            setup_cmd: |
              sudo apt-get update
              sudo apt-get install -y gcc-riscv64-linux-gnu g++-riscv64-linux-gnu
            cross_cc: riscv64-linux-gnu-gcc
            cross_cxx: riscv64-linux-gnu-g++
            folder: linux_riscv64

    env:
      VCPKG_ROOT: ${{ github.workspace }}/vcpkg

    steps:
      - uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: Setup Android NDK
        if: matrix.is_android
        uses: nttld/setup-ndk@v1
        id: setup-ndk
        with:
          ndk-version: r25c

      - name: Export NDK Env
        if: matrix.is_android
        run: echo "ANDROID_NDK_HOME=${{ steps.setup-ndk.outputs.ndk-path }}" >> $GITHUB_ENV

      - name: Install System Dependencies
        if: matrix.setup_cmd
        run: ${{ matrix.setup_cmd }}

      - name: Setup Vcpkg
        run: |
          git clone https://github.com/microsoft/vcpkg.git $VCPKG_ROOT
          cd $VCPKG_ROOT
          if [ "${{ runner.os }}" = "Windows" ]; then
            ./bootstrap-vcpkg.bat
          else
            ./bootstrap-vcpkg.sh
          fi

      - name: Patch Opus for Linux ARM32
        if: matrix.patch_opus
        run: |
          PORTFILE="$VCPKG_ROOT/ports/opus/portfile.cmake"
          sed -i 's/vcpkg_cmake_configure(/vcpkg_cmake_configure(OPTIONS -DOPUS_DISABLE_INTRINSICS=ON /g' "$PORTFILE"

      - name: Patch Triplet for Android ARM32
        if: matrix.patch_android_arm
        run: |
          TRIPLET_FILE="$VCPKG_ROOT/triplets/community/arm-android.cmake"
          echo 'set(VCPKG_CMAKE_CONFIGURE_OPTIONS "-DANDROID_ARM_NEON=ON")' >> "$TRIPLET_FILE"

      - name: Install Dependencies
        run: |
          $VCPKG_ROOT/vcpkg install vcpkg-cmake --triplet=x64-linux --host-triplet=x64-linux || true
          
          if [ ! -z "${{ matrix.cross_cc }}" ]; then
            export CC=${{ matrix.cross_cc }}
            export CXX=${{ matrix.cross_cxx }}
          fi
          
          $VCPKG_ROOT/vcpkg install libogg opus --triplet ${{ matrix.triplet }}

      - name: Configure CMake
        run: |
          # Use an array for args to handle quoting cleanly
          ARGS=(
            "-DCMAKE_TOOLCHAIN_FILE=$VCPKG_ROOT/scripts/buildsystems/vcpkg.cmake"
            "-DVCPKG_TARGET_TRIPLET=${{ matrix.triplet }}"
            "-DCMAKE_BUILD_TYPE=Release"
            "-DOP_DISABLE_HTTP=ON"
            "-DOP_DISABLE_EXAMPLES=ON"
            "-DOP_DISABLE_DOCS=ON"
          )

          if [ "${{ matrix.is_android }}" == "true" ]; then
             # Crucial: Use the NDK Toolchain so we get correct object files
             ANDROID_CHAINLOAD="$ANDROID_NDK_HOME/build/cmake/android.toolchain.cmake"
             ARGS+=("-DVCPKG_CHAINLOAD_TOOLCHAIN_FILE=$ANDROID_CHAINLOAD")
          fi

          if [ ! -z "${{ matrix.cross_cc }}" ]; then
            export CC=${{ matrix.cross_cc }}
            export CXX=${{ matrix.cross_cxx }}
          fi

          ARGS+=(${{ matrix.extra_cmake_args }})
          cmake -B build -S . "${ARGS[@]}"

      - name: Build
        run: cmake --build build --config Release

      - name: Debug and Repack
        run: |
          # --- ENABLE DEBUGGING ---
          set -x  # This prints every command executed. If it fails, you see where.
          set -e  # Fail immediately on error

          # --- 1. DETERMINE ARCHIVER TOOL ---
          # Default to system 'ar'
          TOOL_AR="ar"
          TOOL_RANLIB="ranlib"

          if [ "${{ matrix.is_android }}" == "true" ]; then
             # Android jobs run on Ubuntu, so we look in the Linux prebuilt folder of the NDK
             TOOL_AR="$ANDROID_NDK_HOME/toolchains/llvm/prebuilt/linux-x86_64/bin/llvm-ar"
             TOOL_RANLIB="$ANDROID_NDK_HOME/toolchains/llvm/prebuilt/linux-x86_64/bin/llvm-ranlib"
             
             echo "Configured for Android. Using: $TOOL_AR"
          fi

          if [ "${{ runner.os }}" == "Windows" ]; then
             # On Windows (Git Bash), 'ar' should be in the path from MinGW setup
             echo "Configured for Windows. Assuming 'ar' is in path."
             # Verify it exists
             which ar || echo "WARNING: ar not found in path!"
          fi

          # --- 2. LOCATE FILES ---
          echo "Locating library files..."
          
          VCPKG_LIB_DIR="$VCPKG_ROOT/installed/${{ matrix.triplet }}/lib"
          BUILD_DIR="$(pwd)/build"

          # Use find to locate files (handling potential .lib vs .a naming)
          LIBOGG=$(find "$VCPKG_LIB_DIR" -name "*ogg.a" -o -name "*ogg.lib" | head -n 1)
          LIBOPUS=$(find "$VCPKG_LIB_DIR" -name "*opus.a" -o -name "*opus.lib" | head -n 1)
          LIBOPUSFILE=$(find "$BUILD_DIR" -name "*opusfile.a" -o -name "*opusfile.lib" | head -n 1)

          echo "Found:"
          echo "  OGG: $LIBOGG"
          echo "  OPUS: $LIBOPUS"
          echo "  OPUSFILE: $LIBOPUSFILE"

          # Fail if any are missing
          if [ -z "$LIBOGG" ] || [ -z "$LIBOPUS" ] || [ -z "$LIBOPUSFILE" ]; then
             echo "ERROR: One or more input libraries could not be found!"
             exit 1
          fi

          # --- 3. EXECUTE REPACK ---
          # Strategy: Copy all three to a temp dir, extract all, combine.
          
          if [ "${{ runner.os }}" == "macOS" ]; then
             echo "Using libtool for macOS..."
             libtool -static -o "$BUILD_DIR/libopusfile_combined.a" "$LIBOPUSFILE" "$LIBOPUS" "$LIBOGG"
             
             # Also normalize names to .a in build dir
             cp "$LIBOPUSFILE" "$BUILD_DIR/libopusfile.a"
             cp "$LIBOPUS" "$BUILD_DIR/libopus.a"
             cp "$LIBOGG" "$BUILD_DIR/libogg.a"
             
          else
             echo "Starting Generic/Android Repack..."
             
             # Create a clean workspace
             WORK_DIR="build/repack_work"
             rm -rf "$WORK_DIR"
             mkdir -p "$WORK_DIR"
             
             # Function to copy and extract
             extract_lib() {
                local LIB_PATH="$1"
                local NAME="$2"
                
                echo "Extracting $NAME..."
                mkdir -p "$WORK_DIR/$NAME"
                cp "$LIB_PATH" "$WORK_DIR/$NAME/lib.a"
                
                # Go into dir to extract
                pushd "$WORK_DIR/$NAME" > /dev/null
                "$TOOL_AR" x lib.a
                rm lib.a
                popd > /dev/null
             }

             extract_lib "$LIBOGG" "ogg"
             extract_lib "$LIBOPUS" "opus"
             extract_lib "$LIBOPUSFILE" "opusfile"
             
             # Combine
             echo "Creating combined library..."
             mkdir -p "$WORK_DIR/combined"
             cd "$WORK_DIR/combined"
             
             # We glob all .o files from the extracted folders
             # Important: We must ensure no naming conflicts. Usually these libs are safe.
             cp ../ogg/*.o .
             cp ../opus/*.o .
             cp ../opusfile/*.o .
             
             "$TOOL_AR" crs "$BUILD_DIR/libopusfile_combined.a" *.o
             "$TOOL_RANLIB" "$BUILD_DIR/libopusfile_combined.a"
             
             # Also create standalone repacked libs (to fix thin archives)
             cd ..
             "$TOOL_AR" crs "$BUILD_DIR/libogg.a" ogg/*.o
             "$TOOL_AR" crs "$BUILD_DIR/libopus.a" opus/*.o
             "$TOOL_AR" crs "$BUILD_DIR/libopusfile.a" opusfile/*.o
             
             "$TOOL_RANLIB" "$BUILD_DIR/libogg.a"
             "$TOOL_RANLIB" "$BUILD_DIR/libopus.a"
             "$TOOL_RANLIB" "$BUILD_DIR/libopusfile.a"
             
             echo "Repack complete."
          fi
          
          # List results
          ls -l "$BUILD_DIR"/*.a

      - name: Organize Staging
        run: |
          TARGET="staging/${{ matrix.folder }}"
          TARGET_LIB="$TARGET/lib"
          TARGET_INC="$TARGET/include"
          mkdir -p "$TARGET_LIB" "$TARGET_INC"

          BUILD_DIR="$(pwd)/build"
          
          # Copy the files we just created/verified
          cp "$BUILD_DIR/libogg.a" "$TARGET_LIB/"
          cp "$BUILD_DIR/libopus.a" "$TARGET_LIB/"
          cp "$BUILD_DIR/libopusfile.a" "$TARGET_LIB/"
          cp "$BUILD_DIR/libopusfile_combined.a" "$TARGET_LIB/"

          # Copy Headers
          VCPKG_INC_DIR="$VCPKG_ROOT/installed/${{ matrix.triplet }}/include"
          if [ -d "$VCPKG_INC_DIR" ]; then
             cp -r "$VCPKG_INC_DIR/"* "$TARGET_INC/"
          fi
          if [ -d "include" ]; then
             cp -r "include/"* "$TARGET_INC/"
          fi

      - name: Upload Partial Artifact
        uses: actions/upload-artifact@v4
        with:
          name: part-${{ matrix.folder }}
          path: staging/
          retention-days: 1

  package:
    name: Package All Platforms
    needs: build
    runs-on: ubuntu-latest
    steps:
      - name: Download All Artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: part-*
          merge-multiple: true
          path: final_package

      - name: Upload Final Unified Artifact
        uses: actions/upload-artifact@v4
        with:
          name: libopusfile-all-platforms
          path: final_package/
